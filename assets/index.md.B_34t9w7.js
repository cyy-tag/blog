import{d as u,B as p,o,c as s,j as e,F as a,C as m,k as c,G as l,w as f,a as C,t as r,_ as h}from"./chunks/framework.P9qPzDnn.js";const x=JSON.parse('[{"frontmatter":{"title":"C++并发设计：线程池设计（二）— 代码实现","description":"本文章通过C++并发设计：线程池设计（一）项目代码分析文章总结的线程池设计框架，以及代码设计的优秀之处，结合各个项目的优点，然后再进行整合，采用C++23标准最终实现自己的线程池代码，这里更关注设计，因此采用C++23标准可以直接使用move_only_function，而减少实现上的复杂性，兼容低版本可以自身实现move_only_func，并使用C++concepts对模板参数进行约束。\\n","date":"2025/01/01"},"url":"/posts/C++/C++并发设计：线程池设计（二）— 代码实现.html"},{"frontmatter":{"title":"C++并发设计：线程池设计（一）— 项目代码分析","description":"本篇文章通过介绍和总结当前开源的C++线程池（按照讲解顺序，依次为CTPL、thread-pool)  \\n设计代码实现、分析单队列和多队列俩者的实现方式，以及异步执行获取结果方式\\nC++20 binary_semaphore和jthread新特性使用和讨论。\\n","date":"2024/12/29"},"url":"/posts/C++/C++并发设计：线程池设计（一）— 项目代码分析.html"},{"frontmatter":{"title":"C++notify_one：何时需要加锁","description":"该文章主要分析对std::condition_variable中notify_one和wait的使用以及分析notify_one需要加锁和不需要加锁的俩种情况，以及虚假唤醒处理，并给出最佳实现方式。\\n","date":"2024/12/28"},"url":"/posts/C++/C++notify_one：何时需要加锁.html"}]'),y={class:"post_list"},v=["href"],b={class:"description"},P=u({__name:"PostList",setup(i){return(d,t)=>{const _=p("date");return o(),s(a,null,[t[1]||(t[1]=e("h1",{class:"recent_post"},"Recent Posts",-1)),t[2]||(t[2]=e("br",null,null,-1)),t[3]||(t[3]=e("div",{id:"test"},null,-1)),t[4]||(t[4]=e("br",null,null,-1)),e("ul",y,[(o(!0),s(a,null,m(c(x),n=>(o(),s("li",null,[l(_,null,{default:f(()=>[C(r(n.frontmatter.date),1)]),_:2},1024),t[0]||(t[0]=e("br",null,null,-1)),e("a",{href:n.url,class:"post_url"},r(n.frontmatter.title),9,v),e("p",b,r(n.frontmatter.description),1)]))),256))])],64)}}}),N=h(P,[["__scopeId","data-v-64fc9e18"]]),L=JSON.parse('{"title":"","description":"","frontmatter":{"layout":"home"},"headers":[],"relativePath":"index.md","filePath":"index.md"}'),g={name:"index.md"},j=Object.assign(g,{setup(i){return(d,t)=>(o(),s("div",null,[l(N)]))}});export{L as __pageData,j as default};
